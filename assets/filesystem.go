// Code generated by shogo82148/assets-life v1.0.0. DO NOT EDIT.

//go:generate go run assets-life.go "." . assets

package assets

import (
	"io"
	"net/http"
	"os"
	"path"
	"sort"
	"strings"
	"time"
)

// Root is the root of the file system.
var Root http.FileSystem = fileSystem{
	file{
		name:    "/",
		content: "",
		mode:    0755 | os.ModeDir,
		next:    0,
		child:   1,
	},
	file{
		name:    "/filesystem.go",
		content: "// Code generated by shogo82148/assets-life v1.0.0. DO NOT EDIT.\n\n//go:generate go run assets-life.go \".\" . assets\n\npackage assets\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Root is the root of the file system.\nvar Root http.FileSystem = fileSystem{\n\tfile{\n\t\tname:    \"/\",\n\t\tcontent: \"\",\n\t\tmode:    0755 | os.ModeDir,\n\t\tnext:    0,\n\t\tchild:   1,\n\t},\n\tfile{\n\t\tname:    \"/filesystem.go\",\n",
		mode:    0644,
		next:    2,
		child:   -1,
	},
	file{
		name:    "/views",
		content: "",
		mode:    0755 | os.ModeDir,
		next:    -1,
		child:   3,
	},
	file{
		name:    "/views/index.html",
		content: "<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Dota2 Cog</title>\n</head>\n<body>\n  <h1>Dota2 Cog</h1>\n  <p>Discordの役職に自動でDota2のランク(メダル)を割り当てるbotです</p>\n  <p>1時間に1回、自動でOpenDotaから情報を取ってきて役職を割り当てます</p>\n  <hr>\n  <h3>使い方</h3>\n  <h4>サーバーアドミン</h4>\n  <p><a href=\"/add-bot\" target=\"_blank\">ここ</a>からサーバーにbotを追加してください</p>\n  <h4>サーバーメンバー</h4>\n  <p>Dota2 Cog ボットにDMで <code>/dota2-cog register</code> コマンドを送って</p>\n  <p>表示されたリンクをクリックし、Steamとの連携を有効にしてください</p>\n  <hr>\n  <h3>コマンドリスト</h3>\n  <h5>/dota2-cog register</h5>\n  <p>SteamとDiscordのIDを連携させます (DM推奨)</p>\n  <h5>/dota2-cog force-fetch</h5>\n  <p>現在のサーバーの全ユーザーのランクを取得します (乱用禁止!) (サーバーコマンドのみ)</p>\n  <hr>\n  <h3>寄付のお願い</h3>\n  <p>Dota2 Cog は無料で使えますが、もしあなたがこのbotの維持に協力してくれるなら寄付をお願いします</p>\n  <p>このサービスの運営には毎月のサーバー代などが掛かっています</p>\n  <script src=\"https://liberapay.com/Moul/widgets/button.js\"></script>\n  <noscript><a href=\"https://liberapay.com/Moul/donate\"><img alt=\"Donate using Liberapay\" src=\"https://liberapay.com/assets/widgets/donate.svg\"></a></noscript>\n  <hr>\n  <h3>その他</h3>\n  <p>本当はDiscordのプロフィールからSteamIDを取得したかったがAPIがサポートしてないのでログインさせるという形になった…</p>\n  <p>1000人以上いるサーバーでは最初の1000人しかデータを取れない 後々何とかする</p>\n  <p>サーバーにいる人全員に連携を促すDMを送るコマンド作りたいがスパム扱いされそう…</p>\n  <p>ソースコード:<a href=\"https://github.com/aoisensi/dota2-cog\">https://github.com/aoisensi/dota2-cog</a></p>\n</body>\n</html>",
		mode:    0644,
		next:    -1,
		child:   -1,
	},
}

type fileSystem []file

func (fs fileSystem) Open(name string) (http.File, error) {
	name = path.Clean("/" + name)
	i := sort.Search(len(fs), func(i int) bool { return fs[i].name >= name })
	if i >= len(fs) || fs[i].name != name {
		return nil, &os.PathError{
			Op:   "open",
			Path: name,
			Err:  os.ErrNotExist,
		}
	}
	f := &fs[i]
	return &httpFile{
		Reader: strings.NewReader(f.content),
		file:   f,
		fs:     fs,
		idx:    i,
		dirIdx: f.child,
	}, nil
}

type file struct {
	name    string
	content string
	mode    os.FileMode
	child   int
	next    int
}

var _ os.FileInfo = (*file)(nil)

func (f *file) Name() string {
	return path.Base(f.name)
}

func (f *file) Size() int64 {
	return int64(len(f.content))
}

func (f *file) Mode() os.FileMode {
	return f.mode
}

var zeroTime time.Time

func (f *file) ModTime() time.Time {
	return zeroTime
}

func (f *file) IsDir() bool {
	return f.Mode().IsDir()
}

func (f *file) Sys() interface{} {
	return nil
}

type httpFile struct {
	*strings.Reader
	file   *file
	fs     fileSystem
	idx    int
	dirIdx int
}

var _ http.File = (*httpFile)(nil)

func (f *httpFile) Stat() (os.FileInfo, error) {
	return f.file, nil
}

func (f *httpFile) Readdir(count int) ([]os.FileInfo, error) {
	ret := []os.FileInfo{}
	if !f.file.IsDir() {
		return ret, nil
	}

	if count <= 0 {
		for f.dirIdx >= 0 {
			entry := &f.fs[f.dirIdx]
			ret = append(ret, entry)
			f.dirIdx = entry.next
		}
		return ret, nil
	}

	ret = make([]os.FileInfo, 0, count)
	for f.dirIdx >= 0 {
		entry := &f.fs[f.dirIdx]
		ret = append(ret, entry)
		f.dirIdx = entry.next
		if len(ret) == count {
			return ret, nil
		}
	}
	return ret, io.EOF
}

func (f *httpFile) Close() error {
	return nil
}
